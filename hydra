#!/usr/bin/env python3
"""HydraStack CLI.

Commands:
  hydra makemessages -l fr
  hydra makemessages --all
  hydra compilemessages -l fr
  hydra compilemessages --all
"""

from __future__ import annotations

import argparse
import ast
import re
import struct
import sys
from pathlib import Path
from typing import Dict, List, Sequence, Set, Tuple

SOURCE_EXTENSIONS = {".ts", ".tsx", ".js", ".jsx"}
TRANSLATION_CALL_PATTERN = re.compile(
    r"\b(?:gettext|_)\(\s*(?P<quote>['\"])(?P<msgid>(?:\\.|(?!\1).)*)\1\s*\)"
)


def normalize_locale_argument(locale: str) -> str:
    value = locale.strip().replace("-", "_")
    if not value:
        raise ValueError("locale cannot be empty")
    if "/" in value or "\\" in value:
        raise ValueError(f"invalid locale: {locale}")
    return value


def decode_js_string(quote: str, value: str) -> str:
    try:
        return ast.literal_eval(f"{quote}{value}{quote}")
    except Exception:
        return value


def decode_po_literal(line: str) -> str:
    line = line.strip()
    if not line.startswith('"') or not line.endswith('"'):
        return ""
    try:
        decoded = ast.literal_eval(line)
    except Exception:
        return line[1:-1]
    if isinstance(decoded, str):
        return decoded
    return str(decoded)


def po_escape(value: str) -> str:
    return (
        value.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")
    )


def discover_msgids(source_root: Path) -> Set[str]:
    msgids: Set[str] = set()
    for path in source_root.rglob("*"):
        if not path.is_file():
            continue
        if path.suffix not in SOURCE_EXTENSIONS:
            continue
        try:
            text = path.read_text(encoding="utf-8")
        except Exception:
            continue
        for match in TRANSLATION_CALL_PATTERN.finditer(text):
            msgid = decode_js_string(match.group("quote"), match.group("msgid")).strip()
            if msgid:
                msgids.add(msgid)
    return msgids


def parse_po(path: Path) -> Dict[str, str]:
    if not path.exists():
        return {}

    entries: Dict[str, str] = {}
    current_msgid: List[str] = []
    current_msgstr: List[str] = []
    mode: str | None = None

    def flush() -> None:
        nonlocal current_msgid, current_msgstr, mode
        msgid = "".join(current_msgid)
        msgstr = "".join(current_msgstr)
        if msgid or msgstr:
            entries[msgid] = msgstr
        current_msgid = []
        current_msgstr = []
        mode = None

    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line:
            flush()
            continue
        if line.startswith("#"):
            continue
        if line.startswith("msgid "):
            flush()
            current_msgid.append(decode_po_literal(line[len("msgid ") :]))
            mode = "msgid"
            continue
        if line.startswith("msgstr "):
            current_msgstr.append(decode_po_literal(line[len("msgstr ") :]))
            mode = "msgstr"
            continue
        if line.startswith("msgstr[0] "):
            current_msgstr.append(decode_po_literal(line[len("msgstr[0] ") :]))
            mode = "msgstr"
            continue
        if line.startswith("msgctxt ") or line.startswith("msgid_plural "):
            continue
        if line.startswith('"'):
            if mode == "msgid":
                current_msgid.append(decode_po_literal(line))
            elif mode == "msgstr":
                current_msgstr.append(decode_po_literal(line))
            continue

    flush()
    return entries


def write_po(path: Path, locale: str, extracted_msgids: Set[str], existing: Dict[str, str]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)

    # Preserve existing translations by unioning current ids with extracted ids.
    all_msgids = sorted(extracted_msgids | {msgid for msgid in existing.keys() if msgid})

    lines: List[str] = []
    lines.append(f"# HydraStack UI translations ({locale})")
    lines.append("msgid \"\"")
    lines.append("msgstr \"\"")
    lines.append(f"\"Language: {locale}\\n\"")
    lines.append("\"Content-Type: text/plain; charset=UTF-8\\n\"")
    lines.append("")

    for msgid in all_msgids:
        msgstr = existing.get(msgid, "")
        lines.append(f"msgid \"{po_escape(msgid)}\"")
        lines.append(f"msgstr \"{po_escape(msgstr)}\"")
        lines.append("")

    path.write_text("\n".join(lines), encoding="utf-8")


def compile_mo(entries: Dict[str, str], output_path: Path) -> None:
    # Keep header (msgid "") if present and compile standard GNU MO layout.
    items: List[Tuple[bytes, bytes]] = []
    for msgid, msgstr in sorted(entries.items(), key=lambda kv: kv[0]):
        items.append((msgid.encode("utf-8"), msgstr.encode("utf-8")))

    ids_blob = b"\x00".join(msgid for msgid, _ in items) + b"\x00"
    strs_blob = b"\x00".join(msgstr for _, msgstr in items) + b"\x00"

    offsets: List[Tuple[int, int, int, int]] = []
    id_offset = 0
    str_offset = 0
    for msgid, msgstr in items:
        offsets.append((len(msgid), id_offset, len(msgstr), str_offset))
        id_offset += len(msgid) + 1
        str_offset += len(msgstr) + 1

    key_table_offset = 7 * 4
    value_table_offset = key_table_offset + len(offsets) * 8
    ids_offset = value_table_offset + len(offsets) * 8
    strs_offset = ids_offset + len(ids_blob)

    output = bytearray()
    output += struct.pack("Iiiiiii", 0x950412DE, 0, len(offsets), key_table_offset, value_table_offset, 0, 0)

    for id_len, id_pos, _, _ in offsets:
        output += struct.pack("II", id_len, ids_offset + id_pos)
    for _, _, str_len, str_pos in offsets:
        output += struct.pack("II", str_len, strs_offset + str_pos)

    output += ids_blob
    output += strs_blob

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_bytes(output)


def resolve_locales(locales_dir: Path, locales: Sequence[str] | None, include_all: bool) -> List[str]:
    selected: List[str] = []

    if include_all:
        for path in sorted(locales_dir.iterdir() if locales_dir.exists() else []):
            if path.is_dir():
                selected.append(path.name)

    if locales:
        for raw in locales:
            normalized = normalize_locale_argument(raw)
            if normalized not in selected:
                selected.append(normalized)

    if not selected:
        raise ValueError("no locale selected. use -l <locale> or --all")

    return selected


def cmd_makemessages(args: argparse.Namespace) -> int:
    root = Path(args.root).resolve()
    source_root = (root / args.source).resolve()
    locales_dir = (root / args.locales_dir).resolve()

    if not source_root.exists():
        raise ValueError(f"source directory not found: {source_root}")

    extracted = discover_msgids(source_root)
    locales = resolve_locales(locales_dir, args.locale, args.all)

    for locale in locales:
        po_path = locales_dir / locale / "LC_MESSAGES" / "messages.po"
        existing = parse_po(po_path)
        write_po(po_path, locale, extracted, existing)
        print(f"[makemessages] updated {po_path}")

    print(f"[makemessages] extracted {len(extracted)} msgid(s) from {source_root}")
    return 0


def cmd_compilemessages(args: argparse.Namespace) -> int:
    root = Path(args.root).resolve()
    locales_dir = (root / args.locales_dir).resolve()
    locales = resolve_locales(locales_dir, args.locale, args.all)

    for locale in locales:
        po_path = locales_dir / locale / "LC_MESSAGES" / "messages.po"
        if not po_path.exists():
            print(f"[compilemessages] skipping missing file: {po_path}")
            continue
        mo_path = po_path.with_suffix(".mo")
        entries = parse_po(po_path)
        compile_mo(entries, mo_path)
        print(f"[compilemessages] wrote {mo_path}")

    return 0


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="hydra")
    parser.add_argument("--root", default=Path(__file__).resolve().parent, help="Project root")
    parser.add_argument(
        "--locales-dir",
        default="ui/locales",
        help="Locales directory relative to project root",
    )

    subparsers = parser.add_subparsers(dest="command", required=True)

    makemessages = subparsers.add_parser("makemessages")
    makemessages.add_argument("-l", "--locale", action="append", help="Locale to update")
    makemessages.add_argument("--all", action="store_true", help="Process all locale directories")
    makemessages.add_argument(
        "--source",
        default="ui/src",
        help="Source directory to scan for gettext/_ calls",
    )
    makemessages.set_defaults(func=cmd_makemessages)

    compilemessages = subparsers.add_parser("compilemessages")
    compilemessages.add_argument("-l", "--locale", action="append", help="Locale to compile")
    compilemessages.add_argument("--all", action="store_true", help="Compile all locale directories")
    compilemessages.set_defaults(func=cmd_compilemessages)

    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    try:
        return int(args.func(args))
    except ValueError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 2


if __name__ == "__main__":
    raise SystemExit(main())
